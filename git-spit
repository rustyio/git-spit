#!/usr/bin/env ruby

require 'colorize'

def log(s, prefix = nil)
  s.lines.each do |line|
    if prefix
      print "[#{prefix}] ".yellow
    else
      print "[local] ".green
    end
    print "#{line.strip}\n"
  end
end

def start_timer
  @last_time = Time.now
end

def elapsed_time
  t = (Time.now - @last_time)
  @last_time = Time.now
  return t
end

def find_remote_endpoint(name)
  # Locate the remote url.
  next_url = false
  url = nil
  IO.read(".git/config").lines.each do |line|
    if /remote\s+"#{name}"/.match(line)
      next_url = true
    end

    if next_url && m = /url\s*=(.*)/.match(line)
      url = m[1].strip
      break
    end
  end

  if url.nil?
    return
  end

  # Split out the url parts.
  url = url.gsub(/^ssh:\/\//, "").gsub(/.git$/, "")
  hostname, *path = url.split("/")
  return hostname, path.join("/")
end

def open_persistent_connection(remote_name, remote_hostname)
  Thread.new do
    Signal.trap("INT") do
      exit(-1)
    end

    log "Opening remote connection to #{remote_hostname}.", remote_name
    system("ssh -N #{remote_hostname} 'sleep 9999999999'")
  end
end

def get_current_ref
  return IO.read(".git/HEAD").gsub("ref:", "").gsub("refs/heads/", "").strip
end

def contains_regex?(strings, regex)
  strings.each do |string|
    return true if regex.match(string)
  end
  return false
end

def contains_prefix?(strings, prefix)
  strings.each do |string|
    return true if string.index(prefix) == 0
  end
  return false
end

def escape_path(path)
  path.gsub(' ', '\ ')
end

def success?
  return $?.exitstatus == 0
end

def exit_loudly(s = nil)
  log (s || "Exiting...").red
  exit(-1)
end

def update_remote_head(remote_name, remote_hostname, remote_path, ref)
  log "Updating remote head to #{ref}."

  # Allow us to push to the currently checked out branch.
  log `ssh #{remote_hostname} '(cd #{escape_path(remote_path)} && git config --local receive.denyCurrentBranch false)' 2>&1`, remote_name
  success? or exit_loudly

  # Push latest commit.
  log `git push --force-with-lease #{remote_name} #{ref}:#{ref} 2>&1`, remote_name
  success? or exit_loudly

  # Pushing to a checked out branch can sometimes add files to the
  # index. Reset the index.
  log `ssh #{remote_hostname} '(cd #{escape_path(remote_path)} && git reset)' 2>&1`, remote_name
  success? or exit_loudly

  # Checkout the latest ref. Don't do any kind of forcing, just in
  # case there were remote edits.
  log `ssh #{remote_hostname} '(cd #{escape_path(remote_path)} && git checkout #{ref})' 2>&1`, remote_name
  success? or exit_loudly

  log "Done."
rescue StandardError => e
  log e.to_s.red
  raise
end

def update_remote_file(remote_name, remote_hostname, remote_path, file)
  elapsed_time()
  log `scp #{escape_path(file)} #{remote_hostname}:#{escape_path(File.join(remote_path, file))}`, remote_name
  success? or exit_loudly
  log "Updated remote file: #{file} (%0.2f s)" % elapsed_time()
rescue StandardError => e
  log e.to_s.red
  raise
end

def update_all_remote_files(remote_name, remote_hostname, remote_path, files)
  files.each do |file|
    update_remote_file(remote_name, remote_hostname, remote_path, file)
  end
rescue StandardError => e
  log e.to_s.red
  raise
end

def delete_remote_file(remote_name, remote_hostname, remote_path, file)
  elapsed_time()
  log `ssh #{remote_hostname} '(cd #{escape_path(remote_path)} && rm #{escape_path(file)})'`, remote_name
  success? or exit_loudly
  log "Deleted remote file: #{file} (%0.2f s)" % elapsed_time()
rescue StandardError => e
  log e.to_s.red
end

def refresh_index(index_modified, index_deleted)
  # Get our list of modified files from .git.
  index_status = `git status --porcelain`
  index_status.lines.each do |line|
    if m = /D\s+(.*)/.match(line.strip)
      index_deleted << m[1]
    elsif m = /.\s+(.*)/.match(line.strip)
      index_modified << m[1]
    end
  end

  # Remove duplicate entries and return.
  return index_modified.uniq, index_deleted.uniq
end

# Begin the timer.
start_timer()

# Keep track of which files have been modified. Calls to `git status` feed
# into this, but we have to maintain this across multiple cycles of Listen
# because we may have changed a file, sent it to our remote server, and then
# reverted it back to its original form. In this case, even though `git
# status` will tell us that the file hasn't changed, *we* know it has changed.
index_modified, index_deleted = refresh_index([], [])

base_path = (File.expand_path(".") + "/").gsub("//", "/")
remote_name = ARGV[0] || "origin"
remote_hostname, remote_path = find_remote_endpoint(remote_name)
if remote_hostname.nil? || remote_path.nil?
  remote_name     = ARGV[0]
  remote_hostname = ARGV[0]
  remote_path     = ARGV[1]
end

log "Monitoring #{base_path}"
log "Spitting to #{remote_name} (HOST: #{remote_hostname} DIRECTORY: #{remote_path})"

# Open a persistent connection to speed up calls.
# ssh_thread = open_persistent_connection(remote_name, remote_hostname)

# Update the remote repo to be the same as the local repo.
current_ref = get_current_ref
update_remote_head(remote_name, remote_hostname, remote_path, current_ref)

# index_modified, index_deleted = refresh_index(index_modified, index_deleted)
# update_all_remote_files(remote_name, remote_hostname, remote_path, index_modified)

def get_file_state(path)
  if !File.exists?(path)
    return nil
  end

  return {
    :size  => File.size(path),
    :mtime => File.mtime(path)
  }
end


def detect_file_event(previous_state, new_state)
  # Check if new.
  if previous_state.nil? && new_state
    return :new
  end

  # Check if deleted.
  if previous_state && new_state.nil?
    return :deleted
  end

  # Check if modified
  if previous_state != new_state
    return :modified
  end

  return nil
end


def is_git_head?(path)
  /\.git\/HEAD/.match(path)
end

def is_git_ref?(path)
  /\.git\/refs\/heads\//.match(path)
end


file_states = {}

while true
  # Update our knowledge of remote refs.
  remote_refs = [".git/HEAD"] + Dir[".git/refs/heads/*"]

  # Update our knowledge of the index status.
  index_modified, index_deleted = refresh_index(index_modified, index_deleted)

  (remote_refs + file_states.keys + index_modified + index_deleted).each do |path|
    # Get the states, detect the event.
    old_state = file_states[path]
    new_state = get_file_state(path)
    event = detect_file_event(old_state, new_state)

    # Save the new state.
    file_states[path] = new_state

    # Handle branch changes.
    if is_git_head?(path) && event == :modified
      current_ref = get_current_ref
      update_remote_head(remote_name, remote_hostname, remote_path, current_ref)
    end

    # Handle commits.
    if is_git_ref?(path) && event == :modified
      current_ref = get_current_ref
      if path.index(current_ref)
        update_remote_head(remote_name, remote_hostname, remote_path, current_ref)
      end
    end

    # Ignore any other git head or git ref events.
    next if is_git_head?(path) || is_git_ref?(path)

    # Handle new or modified events.
    if (event == :new || event == :modified)
      update_remote_file(remote_name, remote_hostname, remote_path, path)
    end

    # Handle deleted events.
    if (event == :deleted)
      delete_remote_file(remote_name, remote_hostname, remote_path, path)
      file_states.delete(path)
    end
  end

  sleep 0.5
end
