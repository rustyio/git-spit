#!/usr/bin/env ruby

def log(s, prefix = nil)
  s.lines.each do |line|
    if prefix
      print color("[#{prefix}] ", :yellow)
    else
      print color("[local] ", :green)
    end
    print "#{line.strip}\n"
  end
end

def color(s, color, bold = false)
  color ||= :blue
  bold_code = bold ? "1" : "0"

  color_code = {
    :black  => 30,
    :red    => 31,
    :green  => 32,
    :yellow => 33,
    :blue   => 34,
    :purple => 35,
    :cyan   => 36,
    :white  => 37,
  }[color]

  return "\e[#{bold_code};#{color_code}m#{s}\e[0m"
end

def start_timer
  @last_time = Time.now
end

def elapsed_time
  t = (Time.now - @last_time)
  @last_time = Time.now
  return t
end

def find_remote_endpoint(name)
  # Locate the remote url.
  next_url = false
  url = nil
  IO.read(".git/config").lines.each do |line|
    if /remote\s+"#{name}"/.match(line)
      next_url = true
    end

    if next_url && m = /url\s*=(.*)/.match(line)
      url = m[1].strip
      break
    end
  end

  if url.nil?
    return
  end

  # Split out the url parts.
  url = url.gsub(/^ssh:\/\//, "").gsub(/.git$/, "")
  hostname, *path = url.split("/")
  return hostname, path.join("/")
end

def get_current_ref
  return IO.read(".git/HEAD").gsub("ref:", "").gsub("refs/heads/", "").strip
end

def contains_regex?(strings, regex)
  strings.each do |string|
    return true if regex.match(string)
  end
  return false
end

def contains_prefix?(strings, prefix)
  strings.each do |string|
    return true if string.index(prefix) == 0
  end
  return false
end

def escape_path(path)
  path.gsub(' ', '\ ')
end

def success?
  return $?.exitstatus == 0
end

def exit_loudly(s = nil)
  log colorize(s || "Exiting...", :red)
  exit(-1)
end

def update_remote_head(remote_name, remote_hostname, remote_path, ref)
  log "Updating remote head to #{ref}."

  # Allow us to push to the currently checked out branch.
  log `ssh #{remote_hostname} '(cd #{escape_path(remote_path)} && git config --local receive.denyCurrentBranch false)' 2>&1`, remote_name
  success? or exit_loudly

  # Push latest commit.
  log `git push --force-with-lease #{remote_name} #{ref}:#{ref} 2>&1`, remote_name
  success? or exit_loudly

  # Pushing to a checked out branch can sometimes add files to the
  # index. Reset the index.
  log `ssh #{remote_hostname} '(cd #{escape_path(remote_path)} && git reset)' 2>&1`, remote_name
  success? or exit_loudly

  # Checkout the latest ref. Don't do any kind of forcing, just in
  # case there were remote edits.
  log `ssh #{remote_hostname} '(cd #{escape_path(remote_path)} && git checkout #{ref})' 2>&1`, remote_name
  success? or exit_loudly

  log "Done."
end

def update_remote_file(remote_name, remote_hostname, remote_path, file)
  elapsed_time()
  log `scp #{escape_path(file)} #{remote_hostname}:#{escape_path(File.join(remote_path, file))}`, remote_name
  success? or exit_loudly
  log "Updated remote file: #{file} (%0.2f s)" % elapsed_time()
end

def update_all_remote_files(remote_name, remote_hostname, remote_path, files)
  files.each do |file|
    update_remote_file(remote_name, remote_hostname, remote_path, file)
  end
end

def delete_remote_file(remote_name, remote_hostname, remote_path, file)
  elapsed_time()
  log `ssh #{remote_hostname} '(cd #{escape_path(remote_path)} && rm #{escape_path(file)})'`, remote_name
  success? or exit_loudly
  log "Deleted remote file: #{file} (%0.2f s)" % elapsed_time()
end

def git_status()
  paths = []
  index_status = `git status --porcelain`
  index_status.lines.each do |line|
    if m = /.\s+(.*)/.match(line.strip)
      paths << m[1]
    end
  end

  return paths.uniq
end

def get_file_state(path)
  if !File.exists?(path)
    return nil
  end

  return {
    :size  => File.size(path),
    :mtime => File.mtime(path)
  }
end

def detect_file_event(previous_state, new_state)
  # Check if new.
  if previous_state.nil? && new_state
    return :new
  end

  # Check if deleted.
  if previous_state && new_state.nil?
    return :deleted
  end

  # Check if modified
  if previous_state != new_state
    return :modified
  end

  return nil
end

def is_git_head?(path)
  /\.git\/HEAD/.match(path)
end

def is_git_ref?(path)
  /\.git\/refs\/heads\//.match(path)
end

# Begin the timer.
start_timer()

base_path = (File.expand_path(".") + "/").gsub("//", "/")
remote_name = ARGV[0] || "origin"
remote_hostname, remote_path = find_remote_endpoint(remote_name)
if remote_hostname.nil? || remote_path.nil?
  remote_name     = ARGV[0]
  remote_hostname = ARGV[0]
  remote_path     = ARGV[1]
end

log "Monitoring #{base_path}"
log "Spitting to #{remote_name} (HOST: #{remote_hostname} DIRECTORY: #{remote_path})"

# Update the remote repo to be the same as the local repo.
current_ref = get_current_ref
update_remote_head(remote_name, remote_hostname, remote_path, current_ref)

def handle_file_events(paths, states, &block)
  (paths + states.keys).uniq.each do |path|
    # Get the states, detect the event.
    old_state = states[path]
    new_state = get_file_state(path)
    event = detect_file_event(old_state, new_state)

    # Save the new state.
    if new_state
      states[path] = new_state
    else
      states.delete(path)
    end

    # Call the block.
    block.call(path, event)
  end
end

git_file_states = {}
code_file_states = {}


while true
  # Handle branch changes and commits.
  git_paths = [".git/HEAD"] + Dir[".git/refs/heads/*"]
  handle_file_events(git_paths, git_file_states) do |path, event|
    # Handle branch changes.
    if is_git_head?(path) && event == :modified
      current_ref = get_current_ref
      update_remote_head(remote_name, remote_hostname, remote_path, current_ref)
      code_file_states = {}
    end

    # Handle commits.
    if is_git_ref?(path) && event == :modified
      current_ref = get_current_ref
      if path.index(current_ref)
        update_remote_head(remote_name, remote_hostname, remote_path, current_ref)
      end
      code_file_states = {}
    end
  end

  # Handle code file changes.
  code_paths = git_status()
  handle_file_events(code_paths, code_file_states) do |path, event|
    # Handle new or modified events.
    if (event == :new || event == :modified)
      update_remote_file(remote_name, remote_hostname, remote_path, path)
    end

    # Handle deleted events.
    if (event == :deleted)
      delete_remote_file(remote_name, remote_hostname, remote_path, path)
    end
  end

  sleep 0.5
end
